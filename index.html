<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Setlist Streamer</title>

<!-- PWA + Icons -->
<link rel="manifest" href="manifest.json?v=3">
<meta name="theme-color" content="#0f0f10">
<link rel="icon" href="icons/logo-32.png?v=3" sizes="32x32" type="image/png">
<link rel="icon" href="icons/logo-192.png?v=3" sizes="192x192" type="image/png">
<link rel="apple-touch-icon" href="icons/logo-180.png?v=3" sizes="180x180">
<link rel="shortcut icon" href="icons/logo-32.png?v=3" type="image/png">

<link rel="preconnect" href="https://archive.org">

<style>
  :root{
    --bg:#0f0f10; --panel:#161719; --text:#e9e9ea; --muted:#a6a6ac; --accent:#5bd19a;
    --btn:#232428; --ring:#2b2d31; --warn:#ffd54a; /* yellow */
  }
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--text); font:13px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}

  a{color:inherit; text-decoration:none}

  .wrap{min-height:100%; display:flex; flex-direction:column}

  /* ====== APP HEADER ====== */
  header{
    padding:8px 10px; display:flex; align-items:center; gap:10px;
    background:var(--panel); position:sticky; top:0; z-index:8;
    box-shadow:0 1px 0 #000 inset, 0 1px 0 rgba(255,255,255,.03)
  }
  .headLeft{display:flex; align-items:center; gap:8px; min-width:42px}
  .hamburger{min-width:42px; min-height:36px; border-radius:10px; background:var(--btn); border:1px solid var(--ring); cursor:pointer; display:flex; align-items:center; justify-content:center}
  .hamburger span{display:block; width:18px; height:2px; background:#ccc; position:relative}
  .hamburger span::before, .hamburger span::after{content:""; position:absolute; left:0; width:18px; height:2px; background:#ccc}
  .hamburger span::before{top:-6px} .hamburger span::after{top:6px}

  .headCenter{flex:1; display:flex; justify-content:center; pointer-events:none}
  #pageTitle{font-size:16px; font-weight:600; text-align:center; max-width:80vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
  .crumb{opacity:.75; font-weight:400}
  .headRight{min-width:42px; display:flex; justify-content:flex-end; gap:8px}
  .headerActions .btn{min-height:32px; min-width:32px; padding:6px 10px; border-radius:10px}

  /* Secondary line (band name centered) */
  .subHeader{
    display:none; align-items:center; justify-content:center; gap:8px;
    padding:6px 10px; background:var(--panel); border-top:1px solid var(--ring);
  }
  .subHeader.show{display:flex}
  #bandName{font-weight:700; color:var(--text);}
  #favBandBtn{background:transparent; border:1px solid var(--ring); border-radius:999px; padding:4px 10px; cursor:pointer}
  #favBandBtn.fav{color:var(--warn); border-color:#4a3b0a; background:#1c1a12}

  /* Toolbars */
  .toolbar{display:flex; gap:8px; padding:10px 12px; align-items:center; flex-wrap:wrap}
  .pill{background:var(--panel); border:1px solid var(--ring); border-radius:999px; padding:8px 12px; display:flex; align-items:center; gap:8px}
  select, input[type="search"]{background:transparent; color:var(--text); border:none; outline:none; font:14px system-ui; min-width:120px}
  .btn{background:var(--btn); color:var(--text); border:1px solid var(--ring); border-radius:12px; padding:10px 12px; display:inline-flex; align-items:center; justify-content:center; gap:6px; min-width:40px; min-height:40px; cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .ghost{background:transparent}
  .muted{color:var(--muted)}
  .chip{background:var(--panel); border:1px solid var(--ring); border-radius:999px; padding:6px 10px; font-size:11px; color:var(--muted)}
  .pillBtn{background:var(--panel); border:1px solid var(--ring); border-radius:999px; padding:6px 10px; font-size:11px; cursor:pointer; color:var(--text)}
  .pill-sm{ padding:4px 8px; font-size:11px; }

  /* Visual ON state for toggles */
  .is-on{ color:var(--warn)!important; border-color:#4a3b0a!important; background:#1c1a12!important }

  /* Custom dropdowns */
  .dropdown{position:relative; min-width:150px; cursor:pointer}
  .dropBtn{background:transparent; border:none; color:var(--text); font:14px; width:100%; text-align:left; padding:0; pointer-events:none}
  .menu{
    position:absolute; top:110%; left:0; right:0;
    background:var(--panel); border:1px solid var(--ring); border-radius:12px;
    box-shadow:0 8px 24px rgba(0,0,0,.45);
    display:none; max-height:280px; overflow:auto; z-index:50;
  }
  .menu.open{display:block}
  .menu .item{padding:9px 12px; cursor:pointer; white-space:nowrap}
  .menu .item:hover{background:#202124}

/* Bands grid — tighter tiles so you get ~5 across on laptops */
.bandsGrid{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(132px, 1fr)); /* was 156px + auto-fill */
  gap:10px;
  padding:0 12px 120px;
}

.bandTile{
  background:var(--panel);
  border:1px solid var(--ring);
  border-radius:12px;
  padding:8px;                 /* was 10px */
  display:flex;
  flex-direction:column;
  gap:8px;
  cursor:pointer;
}

.bandTile img{
  width:100%;
  aspect-ratio:1/1;
  object-fit:cover;
  border-radius:10px;
  background:#0c0c0d;
}

/* Title wraps but never overflows; keep cards tidy */
.bandTitle{
  font-weight:600;
  font-size:12px;              /* was 13px */
  line-height:1.25;
  white-space:normal;
  overflow:hidden;
  display:-webkit-box;
  -webkit-box-orient:vertical;
  -webkit-line-clamp:2;        /* two natural lines, no ellipsis overflow */
}

/* Views never truncate */
.bandViews{
  font-size:11px;
  color:var(--muted);
  white-space:normal;
  overflow:visible;
  text-overflow:clip;
}

/* Optional: nudge sizes back up on wide screens while keeping 5+ across */
@media (min-width: 1200px){
  .bandsGrid{ grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
}

  /* Lists */
.grid{display:grid; grid-template-columns:1fr; gap:8px; padding:0 12px 120px}

/* Cards: ensure left column can shrink; right column (buttons) never pushes page wide */
.card{
  background:var(--panel); border:1px solid var(--ring); border-radius:14px;
  padding:12px; display:flex; justify-content:space-between; align-items:center;
}
.card.tap{cursor:pointer}

/* Let both direct children participate in flex shrinking */
.card > *{ min-width:0; }
.card > :first-child{ flex:1 1 auto; }   /* text side */
.card > :last-child{  flex:0 0 auto; }   /* buttons */

/* Long titles inside cards truncate instead of pushing layout */
.card h3{ margin:0 0 6px 0; font-size:15px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }

/* Row helper used inside cards — allow it to shrink within parent */
.row{
  display:flex; gap:8px; align-items:center; flex-wrap:wrap; min-width:0;
}
.small{font-size:12px; color:var(--muted)}
.favToggle{min-width:40px}
.loadMore{justify-content:center}

  .small{font-size:12px; color:var(--muted)}
  .favToggle{min-width:40px}
  .loadMore{justify-content:center}

  /* Tracks */
  .tracks{display:grid; gap:6px; padding:0 12px 120px}
/* Generic track row (used by Show page and “recent/fav songs”) */
.track{
  position:relative;
  background:var(--panel); border:1px solid var(--ring); border-radius:12px;
  padding:10px 12px;
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  min-width:0; /* allow the whole row to shrink */
}

/* left side can grow/shrink; right side (length) stays tight */
.tleft{ display:flex; gap:10px; align-items:center; flex:1 1 auto; min-width:0; }
.tnum{ width:18px; text-align:right; color:var(--muted); font-size:12px; flex:0 0 auto; }
.tname{
  font-size:13px; flex:1 1 auto; min-width:0;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
.tlen{ font-size:12px; color:var(--muted); flex:0 0 auto; }

.track.playing{ box-shadow:0 0 0 2px rgba(255,213,74,.25) inset }
.track.playing::before{ content:""; position:absolute; left:0; top:0; bottom:0; width:6px; background:var(--warn); border-radius:12px 0 0 12px }

.progressBar{
  position:absolute; left:0; bottom:0; height:3px; background:var(--warn);
  border-radius:0 0 12px 12px; width:0%;
}

.songFav{
  min-width:32px; min-height:32px;
  border-radius:10px; border:1px solid var(--ring);
  background:transparent;
  color:var(--text);              /* default = white */
}
.songFav.is-on{                   /* favorited = yellow */
  color:var(--warn);
}


  /* Pulse the track briefly when we deep-link to it */
@keyframes pulseTrack {
  0%   { box-shadow:0 0 0 2px rgba(255,213,74,.45) inset }
  100% { box-shadow:0 0 0 0   rgba(255,213,74,0) inset }
}
.track.pulse { animation: pulseTrack .9s ease-out 2; }

  
  /* Show meta */
  .showMeta{display:flex; gap:8px; flex-wrap:wrap; align-items:center; padding:6px 12px 8px}
  .showTitle{font-weight:600; margin-right:6px}
  .showMeta .end{margin-left:auto; display:flex; align-items:center}
  .stars{display:inline-flex; align-items:center; gap:4px}

  /* Player (bottom) */
  .player{
    position:fixed; left:0; right:0; bottom:0;
    background:var(--panel);
    border-top:1px solid var(--ring);
    box-shadow:0 -1px 0 #000 inset, 0 -6px 24px rgba(0,0,0,.35);
    padding:10px 12px calc(10px + env(safe-area-inset-bottom));
    z-index:9;
  }
/* ===== Player controls: grid layout so seek never overlaps volume ===== */
.player .controls{
  display:grid;
  /* eq | prev | play | next | seek | volume */
  grid-template-columns: auto auto auto auto 1fr auto;
  align-items:center;
  gap:8px;
  max-width:1000px;
  margin:0 auto;
}

.player .btn{ min-width:42px; min-height:42px; border-radius:12px }

/* keep seek inside its own grid cell; allow it to shrink safely */
.seekWrap{
  display:flex;
  align-items:center;
  gap:10px;
  min-width:0;   /* lets the range actually shrink on narrow screens */
  flex:unset;    /* don’t grow inside grid */
  margin-right:0;/* no manual gutter needed with grid */
}

#P_times{ font-size:12px; color:var(--muted); white-space:nowrap }

#P_seek{
  flex:1;
  width:100%;
  height:6px;
  border:none;
  outline:none;
  border-radius:999px;
  background:#2a2b2f;
  -webkit-appearance:none;
  appearance:none;
}

/* make sure the volume area holds its column width */
.volWrap{ min-width:42px }


  #P_seek::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; border-radius:50%; background:#7bdcaa; border:none;}
  #P_seek::-moz-range-thumb{ width:14px; height:14px; border-radius:50%; background:#7bdcaa; border:none;}

  /* Equalizer Now Playing */
  .eqBtn{ width:42px; height:42px; border-radius:12px; border:1px solid var(--ring); background:var(--btn); display:flex; align-items:center; justify-content:center; cursor:pointer }
  .eqBars{ display:inline-flex; align-items:flex-end; gap:3px; width:18px; height:16px }
  .eqBars span{ width:4px; background:#7bdcaa; border-radius:2px; animation:eq 1.1s infinite ease-in-out; transform-origin:bottom }
  .eqBars span:nth-child(1){ animation-delay:0s }
  .eqBars span:nth-child(2){ animation-delay:.15s }
  .eqBars span:nth-child(3){ animation-delay:.3s }
  @keyframes eq { 0%,100%{height:20%} 25%{height:80%} 50%{height:40%} 75%{height:70%} }
  .eqBars.paused span{ animation-play-state:paused; opacity:.6; }

  /* Volume popover */
  .volWrap{position:relative}
  .volPop{
    position:fixed; left:50%; transform:translateX(-50%); bottom:72px;
    background:var(--panel); border:1px solid var(--ring); border-radius:12px;
    padding:10px 12px; box-shadow:0 8px 24px rgba(0,0,0,.45); display:none;
    width:260px; max-width:90vw; z-index:40;
  }
  .volPop.open{display:block}
  .volRow{display:flex; align-items:center; gap:10px}
  #P_vol{flex:1; height:6px; border:none; border-radius:999px; background:#2a2b2f; -webkit-appearance:none; appearance:none;}
  #P_vol::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; border-radius:50%; background:#7bdcaa; border:none;}
  #P_vol::-moz-range-thumb{ width:14px; height:14px; border-radius:50%; background:#7bdcaa; border:none;}

  /* Drawer (left slide-out) */
  .drawerBack{position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; z-index:11}
  .drawerBack.open{display:block}
  .drawer{
    position:fixed; top:0; left:0; bottom:0; width:280px; max-width:85vw;
    background:var(--panel); border-right:1px solid var(--ring); box-shadow: 8px 0 24px rgba(0,0,0,.4);
    transform:translateX(-100%); transition:transform .25s ease; z-index:12; display:flex; flex-direction:column;
  }
  .drawer.open{transform:translateX(0)}
  .drawerHeader{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:12px; border-bottom:1px solid var(--ring)}
  .drawerClose{min-width:36px; min-height:32px; border-radius:8px; border:1px solid var(--ring); background:var(--btn); cursor:pointer}
  .drawerBody{padding:8px 8px 12px; overflow:auto}
  .menuGroup{margin:8px 0 10px}
  .menuTitle{font-size:12px; color:var(--muted); margin:6px 8px}
  .menuItem{display:flex; align-items:center; gap:8px; padding:10px; border-radius:10px; cursor:pointer}
  .menuItem:hover{background:#202124}
  .menuItem .icon{width:18px; text-align:center}
  /* Indent submenu items under Favorites */
  .menuItem.sub{ padding-left:28px; }

  /* Page actions row for favorites lists */
  .pageActions{display:flex; gap:8px; padding:8px 12px; align-items:center}
/* Keep text white in Favorites lists; only star buttons stay yellow via .is-on */
.card.fav .title {
  color: var(--text) !important;
  /* ↓ match Favorites → Songs (tname is 13px) */
  font-size: 13px;
  font-weight: 600;
}
.card.fav .btn:not(.is-on) {
  color: var(--text);
  border-color: var(--ring);
  background: var(--btn);
}
.card.fav a { color: var(--text); }

/* Favorites/Recent → Songs: two-line compact layout */
.track.favsong{ display:block; padding:10px 12px }

/* first line: number + title + (optional) band pill */
.track.favsong .line1{
  display:flex; align-items:center; gap:10px; flex-wrap:nowrap; min-width:0;
}
.track.favsong .line1 .tleft{
  display:flex; align-items:center; gap:10px; flex:1 1 auto; min-width:0;
}
.track.favsong .line1 .tnum{ flex:0 0 auto; color:var(--muted) }
.track.favsong .line1 .tname{
  flex:1 1 auto; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
/* band pill must not push the row wider than viewport */
.track.favsong .line1 .bandpill{
  flex:0 1 auto; max-width:45vw; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
}

/* second line: location (grows, truncates) + date (fixed) */
.track.favsong .line2{
  display:flex; gap:8px; flex-wrap:nowrap; margin-top:6px; margin-left:42px; min-width:0;
}
.track.favsong .line2 .locpill{
  flex:1 1 auto; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
.track.favsong .line2 .datepill{ flex:0 0 auto; white-space:nowrap }
.track.favsong .pill-sm{ padding:3px 8px }

/* never allow these containers to create horizontal scroll */
.wrap, #content, .tracks, .grid { overflow-x: hidden; }



/* This is an override to try to fix it.  */

/* --- Fix concert card overflow (Band -> Concerts, Favorites -> Concerts) --- */
/* Make the left content column shrinkable */
.card.tap > div:first-child {
  min-width: 0;           /* critical: allow inner content to shrink */
  flex: 1 1 auto;         /* keep it flexible */
}

/* Inside that column, make rows shrink and wrap cleanly */
.card.tap > div:first-child .row {
  min-width: 0;
  flex-wrap: wrap;
}
.card.tap > div:first-child .row > * {
  min-width: 0;           /* children can shrink instead of forcing overflow */
}

/* The long venue/city line: wrap or break as needed (no horizontal scroll) */
.card.tap > div:first-child .small {
  min-width: 0;
  overflow-wrap: anywhere; /* break long tokens if needed */
  word-break: break-word;
}

/* Stars shouldn’t force the row wide */
.card.tap .stars {
  flex: 0 1 auto;
  min-width: 0;
}

  
/* --- Recently Played overflow + sticky player fixes --- */
:root { --playerH: 96px; }            /* fallback player height */

html, body { overflow-x: hidden; }    /* kill horizontal scroll globally */

/* Make list rows shrink correctly and ellipsize long text */
.trackRow, .songRow, .listItem, .row {
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0;                       /* allow shrinking */
}

/* Every direct child can shrink */
.trackRow > *, .songRow > *, .listItem > *, .row > * {
  min-width: 0;
}

/* The main text column grows and truncates with ellipsis */
.titleWrap, .title, .mainCol, .midCol, .row .title {
  flex: 1 1 auto;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* The right-side meta stays visible but never pushes layout off screen */
.metaRight, .rightCol, .row .right {
  flex: 0 0 auto;
  max-width: 40vw;                    /* keep it compact on phones */
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Cards: let left column shrink, right column stay tight (prevents overflow) */
.card > *{ min-width:0; }
.card > :first-child{ flex:1 1 auto; }
.card > :last-child{  flex:0 0 auto; }

/* Long titles inside cards never cause horizontal scroll */
.card h3{
  margin:0 0 6px 0; font-size:15px;   /* keeps existing sizing for general cards */
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}

/* Pin the player; content leaves room for it */
#P_bar, #playerBar, .playerBar {
  position: fixed;
  left: 0; right: 0; bottom: 0;
  z-index: 1000;
}

/* Ensure scroll areas don’t hide behind the player */
main, #app, .content, .scrollArea, .routeView {
  padding-bottom: var(--playerH);
}


  /* --- Concert cards: stop horizontal overflow & wrap long titles --- */

/* 1) Make the left content column shrink instead of pushing the card wider */
.card.tap > div:first-child,
.card.fav > div:first-child {
  min-width: 0;
  flex: 1 1 auto;
}

/* 2) Let the chips/stars row shrink/wrap */
.card.tap > div:first-child .row,
.card.fav > div:first-child .row {
  min-width: 0;
  flex-wrap: wrap;
}
.card.tap > div:first-child .row > *,
.card.fav > div:first-child .row > * {
  min-width: 0;
}

/* 3) Venue/city line: allow breaking long strings */
.card.tap > div:first-child .small,
.card.fav > div:first-child .small {
  min-width: 0;
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* 4) Title: clamp to 2 lines (instead of single-line nowrap) */
.card.tap h3,
.card.fav .title {
  margin: 0 0 6px 0;
  font-size: 15px;
  line-height: 1.25;
  white-space: normal;              /* override the global nowrap */
  display: -webkit-box;             /* multi-line clamp */
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;                 /* hide extra lines */
  max-height: calc(1.25em * 2);     /* keeps height consistent cross-browser */
}

/* (Optional) Slightly top-align content so wrapped titles look natural */
.card.tap,
.card.fav {
  align-items: flex-start;
}



  
</style>
</head>
<body>
<div id="statusBanner" hidden data-kind="warn" style="
  position:sticky; top:0; z-index:9999; padding:10px 12px;
  font-size:14px; line-height:1.2; text-align:center;
  background:#fff3cd; color:#664d03; border-bottom:1px solid #ffe69c;
">
  <span id="statusMsg"></span>
  <button id="statusRetryBtn" style="margin-left:8px; padding:4px 8px; border:1px solid #d3a500; background:#ffec99; border-radius:6px; cursor:pointer">
    Try again
  </button>
</div>
<script>
  // optional: wire the button to refresh current view
  document.getElementById('statusRetryBtn')?.addEventListener('click', ()=> location.reload());
</script>
  
<div class="wrap">
  <!-- Header -->
  <header>
    <div class="headLeft">
      <button id="hamburger" class="hamburger" title="Menu" aria-label="Open menu"><span></span></button>
    </div>
    <div class="headCenter">
      <div id="pageTitle">Setlist Streamer <span class="crumb">— Bands</span></div>
    </div>
    <div class="headRight">
      <div id="headerActions" class="headerActions"></div>
    </div>
  </header>

  <!-- Centered band name row (only on concerts route) -->
  <div id="subHeader" class="subHeader">
    <span id="bandName"></span>
    <button id="favBandBtn" class="pillBtn" title="Favorite band">☆</button>
  </div>

  <!-- Drawer -->
  <div id="drawerBack" class="drawerBack"></div>
  <aside id="drawer" class="drawer" aria-label="Main menu">
    <div class="drawerHeader">
      <strong>Menu</strong>
      <button id="drawerClose" class="drawerClose" title="Close">✕</button>
    </div>
    <div class="drawerBody">
<div class="menuGroup">
  <div class="menuItem" data-nav="#/bands"><span class="icon">🏠</span> <span>Home</span></div>
  <div class="menuItem" data-nav="#/favorites"><span class="icon">⭐</span> <span>Favorites</span></div>
  <div class="menuItem sub" data-nav="#/favorites/bands"><span class="icon">🎤</span> <span>Bands</span></div>
  <div class="menuItem sub" data-nav="#/favorites/concerts"><span class="icon">🎫</span> <span>Concerts</span></div>
  <div class="menuItem sub" data-nav="#/favorites/songs"><span class="icon">🎵</span> <span>Songs</span></div>
  <div class="menuItem" data-nav="#/recent"><span class="icon">🕒</span> <span>Recently Played</span></div>
  <div class="menuItem" data-nav="#/onthisday"><span class="icon">📅</span> <span>This Day in History</span></div>
</div>
      <div class="menuGroup">
        <div class="menuTitle">Other</div>
        <div class="menuItem"><span class="icon">🔧</span> <span>Settings (placeholder)</span></div>
        <div class="menuItem"><span class="icon">❓</span> <span>Help (placeholder)</span></div>
      </div>
    </div>
  </aside>

  <!-- Bands toolbar -->
  <div class="toolbar" id="toolbar-bands">
    <div class="pill"><select id="sortSel" aria-label="Sort">
      <option value="downloads desc" selected>Views ↓</option>
      <option value="downloads asc">Views ↑</option>
      <option value="title asc">Title A→Z</option>
      <option value="title desc">Title Z→A</option>
    </select></div>
    <div class="pill"><select id="subjectSel" aria-label="Subject">
      <option value="all" selected>All subjects</option>
    </select></div>
    <div class="pill" style="flex:1 1 160px;"><input id="searchBox" type="search" placeholder="e.g., Grateful Dead, bluegrass" style="width:100%"></div>
    <button id="favToggle" class="btn">☆ Favorites</button>
    <button id="resetBtn" class="btn ghost muted">Reset</button>
  </div>

  <!-- Concerts toolbar -->
  <div class="toolbar" id="toolbar-band" style="display:none;">
    <div class="pill dropdown" id="sortDrop" aria-label="Sort">
      <button class="dropBtn" id="sortBtn">Sort</button>
      <div class="menu" id="sortMenu" role="listbox" aria-label="Sort options">
        <div class="item" data-value="auto">Auto</div>
        <div class="item" data-value="date asc">Date ↑</div>
        <div class="item" data-value="date desc">Date ↓</div>
        <div class="item" data-value="avg_rating desc">Reviews ↓</div>
        <div class="item" data-value="downloads desc">Views ↓</div>
      </div>
    </div>

    <div class="pill dropdown" id="yearDrop" aria-label="Year">
      <button class="dropBtn" id="yearBtn">All years</button>
      <div class="menu" id="yearMenu" role="listbox" aria-label="Year options">
        <div class="item muted">Loading years…</div>
      </div>
    </div>

    <div class="pill" style="flex:1 1 160px;"><input id="concertSearch" type="search" placeholder="Filter (venue/city/title)" style="width:100%"></div>

    <button id="favConcertsToggle" class="btn" title="Show only favorites">☆ Favorites</button>
    <button id="resetConcerts" class="btn ghost muted">Reset</button>
  </div>

  <!-- Show header metadata -->
  <div id="showMeta" class="showMeta" style="display:none;">
    <span class="showTitle" id="showTitle"></span>
    <span class="chip" id="showDate" style="display:none;"></span>
    <span class="chip" id="showLoc"  style="display:none;"></span>
    <div class="end">
      <button class="pillBtn" id="favShowBtn" title="Favorite">☆ Favorite</button>
    </div>
  </div>

  <!-- Dynamic content -->
  <div id="content" class="grid" aria-live="polite"></div>
</div>

<!-- Fixed Player -->
<div class="player" id="player">
  <div class="controls">
    <button id="P_now" class="eqBtn" title="Go to currently playing">
      <span class="eqBars" aria-hidden="true"><span style="height:60%"></span><span style="height:30%"></span><span style="height:45%"></span></span>
    </button>
    <button id="P_prev" class="btn" title="Previous">⏮</button>
    <button id="P_play" class="btn" title="Play/Pause">▶️</button>
    <button id="P_next" class="btn" title="Next">⏭</button>

    <div class="seekWrap">
      <div id="P_times"><span class="cur">0:00</span><span class="dur"> / 0:00</span></div>
      <input id="P_seek" type="range" min="0" max="1000" value="0" step="1" aria-label="Seek">
    </div>

    <div class="volWrap">
      <button id="P_mute" class="btn" title="Volume">🔈</button>
      <div id="volPop" class="volPop" role="dialog" aria-label="Volume">
        <div class="volRow">
          <span class="small" style="min-width:36px">Vol</span>
          <input id="P_vol" type="range" min="0" max="1" step="0.01" value="1" aria-label="Volume">
          <span id="volLabel" class="small" style="min-width:32px;text-align:right">100%</span>
        </div>
      </div>
    </div>
  </div>
  <audio id="audio" crossorigin="anonymous"></audio>
</div>

<script>
/* ------------ utils/store ------------ */
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const fmtTime = secs => { secs = Math.max(0, Math.floor(secs||0)); const m=Math.floor(secs/60), s=secs%60; return m+":"+String(s).padStart(2,"0"); };
const fmtCompact = n => { n=Number(n||0); if(n>=1e9) return (n/1e9).toFixed(1)+'B'; if(n>=1e6) return (n/1e6).toFixed(1)+'M'; if(n>=1e3) return (n/1e3).toFixed(1)+'K'; return String(n); };
function show(el,on=true){ if(!el) return; el.style.display=on?'':'none'; }
const store = { get(k,f){ try{return JSON.parse(localStorage.getItem(k))??f;}catch{return f;}}, set(k,v){ localStorage.setItem(k,JSON.stringify(v)); } };
  
  function todayMMDD(){
  const d = new Date();
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return { mm, dd };
}

/* ------------ drawer ------------ */
const drawer = $('#drawer'); const drawerBack = $('#drawerBack');
$('#hamburger').addEventListener('click', ()=>{ drawer.classList.add('open'); drawerBack.classList.add('open'); });
$('#drawerClose').addEventListener('click', closeDrawer);
drawerBack.addEventListener('click', closeDrawer);
function closeDrawer(){ drawer.classList.remove('open'); drawerBack.classList.remove('open'); }
$$('.drawer .menuItem').forEach(it=>it.addEventListener('click', ()=>{
  const nav=it.getAttribute('data-nav'); if(nav){ location.hash=nav; closeDrawer(); }
}));

/* ------------ router ------------ */
const Router = (() => {
  const routes={};
  function on(n,f){routes[n]=f}
  function parse(){ const raw=location.hash.replace(/^#\/?/,''); const [name,...rest]=raw.split('/').filter(Boolean); return {name:name||'bands', params:rest}; }
  function route(){
    const r = parse();
    // allow nested routes like "favorites/bands"
    const key = r.params.length ? (r.name + '/' + r.params.join('/')) : r.name;
    const handler = routes[key] || routes[r.name] || routes['bands'];

    // Header crumb override for favorites subpages
    let crumbOverride = null;
    if (key === 'favorites/bands') crumbOverride = '— Favorite Bands';
    else if (key === 'favorites/concerts') crumbOverride = '— Favorite Concerts';
    else if (key === 'favorites/songs') crumbOverride = '— Favorite Songs';

    handler(r.params);
    setHeader(r.name, crumbOverride); // header uses top-level route name with optional override
  }
  return {on,route};
})();
addEventListener('hashchange', Router.route); addEventListener('DOMContentLoaded', Router.route);

function setHeader(routeName, crumbOverride=null){
  const titleEl = $('#pageTitle');
const crumbText = crumbOverride ?? (
  routeName==='band' ? '— Concerts' :
  routeName==='show' ? '— Tracks'   :
  routeName==='recent' ? '— Recently Played' :
  routeName==='onthisday' ? '— This Day in History' :
  (routeName==='fav' || routeName==='favorites' ? '— Favorites' :
  (routeName==='playlist' ? '— Playlist' : '— Bands'))
);

  titleEl.innerHTML = `Setlist Streamer <span class="crumb">${crumbText}</span>`;

  // Right side actions (Back buttons)
  const actions = $('#headerActions'); actions.innerHTML='';

  if(routeName==='band'){
    const btn = document.createElement('button');
    btn.className='btn ghost'; btn.title='Back'; btn.textContent='← Bands';
    btn.onclick=()=>{ location.hash = '#/bands'; };
    actions.appendChild(btn);
  }else if(routeName==='show'){
    // Decide where we came from and set label/target
    const cameFrom = store.get('cameFrom', '');
    let backLabel = '← Concerts';
    let backHash = ''; // when empty, we’ll fall back to history.back()

    if (cameFrom === 'favorites-songs') {
      backLabel = '← Favorite Songs';
      backHash  = '#/favorites/songs';
    } else if (cameFrom === 'favorites-concerts') {
      backLabel = '← Favorite Concerts';
      backHash  = '#/favorites/concerts';
    } else if (cameFrom === 'recent') {
      backLabel = '← Recently Played';
      backHash  = '#/recent';
    } else if (cameFrom === 'band') {
      backLabel = '← Concerts';
      backHash  = ''; // prefer history for band flow so year/sort filters persist
    }

    const btn = document.createElement('button');
    btn.className='btn ghost'; btn.title='Back'; btn.textContent=backLabel;
    btn.onclick=()=>{ backHash ? (location.hash = backHash) : history.back(); };
    actions.appendChild(btn);
  }

  // Subheader visibility (band name row only on concerts)
  $('#subHeader').classList.toggle('show', routeName==='band');
}


// old helper — keep if you still use fetchJSON() anywhere
async function fetchWithTimeoutLegacy(url, {timeout=12000}={}){
  const ctrl = new AbortController();
  const id = setTimeout(()=>ctrl.abort(), timeout);
  try{
    const res = await fetch(url, {cache:'no-store', signal: ctrl.signal});
    clearTimeout(id);
    if(!res.ok) throw new Error('HTTP '+res.status);
    return res;
  }catch(e){ clearTimeout(id); throw e; }
}
// and update this right below it:
async function fetchJSON(url){ const r = await fetchWithTimeoutLegacy(url); return r.json(); }


/* ------------ JSONP helper (defensive) ------------ */
function fetchJSONP(url, {timeout=8000}={}) {
  return new Promise((resolve)=>{
    const cb = '__iajsonp_'+Math.random().toString(36).slice(2);
    const s  = document.createElement('script');
    let done = false;

    function cleanup() {
      if (done) return;
      done = true;
      delete window[cb];
      s.remove();
    }

    // Hard timeout so we don’t hang on a bad payload
    const t = setTimeout(()=>{ cleanup(); resolve(null); }, timeout);

    window[cb] = (data)=>{ clearTimeout(t); cleanup(); resolve(data); };

    // If the script 404s or throws a syntax error, onerror will fire.
    s.onerror = ()=>{ clearTimeout(t); cleanup(); resolve(null); };

    // Some CDNs report load but never call our cb (bad JSONP). Guard that too.
    s.onload = ()=>{ /* if cb never called, timeout will resolve null */ };

    s.src = url + (url.includes('?')?'&':'?') + 'callback=' + cb + '&output=json';
    document.head.appendChild(s);
  });
}


/* ------------ Hybrid IA fetch: fetch -> JSONP fallback (CORS-safe) ------------ */
async function fetchIA(url){
  try{
    return await fetchJSON(url);
  }catch(e){
    const data = await fetchJSONP(url);
    if (data) return data;
    throw e;
  }
}

/* ------------ IA helpers ------------ */
// === Archive API fetch with timeout + retries + outage detection ===
const IA_STATUS = { failCount: 0, circuitUntil: 0, lastError: '' };

function showStatus(msg, kind='warn') {
  const el = document.getElementById('statusBanner');
  const msgEl = document.getElementById('statusMsg');
  if (!el || !msgEl) return;
  msgEl.textContent = msg;       // preserve the button
  el.dataset.kind = kind;
  el.hidden = false;
}

function hideStatus(){ const el = document.getElementById('statusBanner'); if (el) el.hidden = true; }

function now(){ return Date.now(); }
function circuitOpen(){ return now() < IA_STATUS.circuitUntil; }
function openCircuit(ms=5*60*1000){ IA_STATUS.circuitUntil = now()+ms; }

function fetchWithTimeout(url, ms=15000, opts={}) {
  const ctl = new AbortController();
  const t = setTimeout(()=>ctl.abort(), ms);
  return fetch(url, {...opts, signal: ctl.signal}).finally(()=>clearTimeout(t));
}

// small cache helpers
function setCache(key, data){ try{ localStorage.setItem(key, JSON.stringify({ts:Date.now(), data})); }catch{} }
function getCache(key){ try{ const v = JSON.parse(localStorage.getItem(key)||''); return v && v.data; }catch{ return null; } }

// One canonical way to call IA
async function iaFetchJSON(url, { cacheKey, retries=2, timeoutMs=15000 } = {}) {
  // If the circuit is open, jump straight to cache and message
  if (circuitOpen()) {
    const cached = cacheKey ? getCache(cacheKey) : null;
    if (cached) {
      showStatus('Archive.org is having trouble; showing cached results (stale).', 'info');
      return { data: cached, stale: true };
    }
    throw new Error('Archive.org temporarily unavailable (cool-down active).');
  }

  let attempt = 0;
  while (true) {
    try {
      const res = await fetchWithTimeout(url, timeoutMs);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      IA_STATUS.failCount = 0; IA_STATUS.lastError = ''; hideStatus();
      if (cacheKey) setCache(cacheKey, data);
      return { data, stale: false };
    } catch (err) {
      attempt++;
      IA_STATUS.failCount++; IA_STATUS.lastError = String(err);
      if (attempt > retries) {
        // Decide if this looks like an outage
        if (IA_STATUS.failCount >= 3) {
          openCircuit(); // 5 minutes
          showStatus('Archive.org seems unreachable. We’ll retry shortly. You can keep browsing cached items.', 'warn');
        } else if (!navigator.onLine) {
          showStatus('You appear to be offline. Reconnect and try again.', 'warn');
        } else {
          showStatus('Trouble reaching Archive.org. Retrying…', 'warn');
        }
        // Cache fallback
        const cached = cacheKey ? getCache(cacheKey) : null;
        if (cached) return { data: cached, stale: true };
        throw err;
      }
      // Backoff: 500ms, 1000ms…
      await new Promise(r=>setTimeout(r, 500 * attempt));
    }
  }
}

// Nice-to-have: react to browser online/offline
window.addEventListener('offline', ()=> showStatus('You are offline. Some features won’t work.', 'warn'));
window.addEventListener('online',  ()=> { hideStatus(); IA_STATUS.failCount = 0; IA_STATUS.circuitUntil = 0; });

  
const IA = {
  bandsUrl({ q='collection:(etree) AND mediatype:(collection)', sort='downloads desc', rows=120 }={}){
    const u=new URL('https://archive.org/advancedsearch.php');
    u.searchParams.set('q',q);
    ['identifier','title','downloads'].forEach(f=>u.searchParams.append('fl[]',f));
    u.searchParams.append('sort[]',sort); u.searchParams.set('rows',rows); u.searchParams.set('page',1); u.searchParams.set('output','json'); return u.toString();
  },
  concertsUrl({ bandId, sort='date desc', rows=200, page=1, year='', term='' }){
    let q=`collection:(${bandId}) AND mediatype:(etree OR audio)`; if(year) q+=` AND year:(${year})`;
    if(term) q+=` AND (title:(${term}) OR date:(${term}) OR venue:(${term}) OR coverage:(${term}))`;
    const u=new URL('https://archive.org/advancedsearch.php'); u.searchParams.set('q',q);
    ['identifier','title','date','year','downloads','avg_rating','num_reviews','venue','coverage','creator','publicdate'].forEach(f=>u.searchParams.append('fl[]',f));
    u.searchParams.append('sort[]',sort); u.searchParams.set('rows',rows); u.searchParams.set('page',page); u.searchParams.set('output','json'); return u.toString();
  },
  // Batch fetch concerts by identifier list (returns same fields as concertsUrl)
  concertsByIdsUrl(ids){
    const u=new URL('https://archive.org/advancedsearch.php');
    const safe = ids.map(id=>`"${id.replace(/"/g,'\"')}"`);
    const q = `identifier:(${safe.join(' OR ')}) AND (mediatype:(etree) OR mediatype:(audio))`;
    u.searchParams.set('q', q);
    ['identifier','title','date','year','downloads','avg_rating','num_reviews','venue','coverage','creator','publicdate','collection']
      .forEach(f=>u.searchParams.append('fl[]',f));
    u.searchParams.append('sort[]','date desc');
    u.searchParams.set('rows', String(ids.length || 50));
    u.searchParams.set('page','1');
    u.searchParams.set('output','json');
    return u.toString();
  },
  yearsOnlyUrl({ bandId, rows=1200, page=1 }){
    const u=new URL('https://archive.org/advancedsearch.php');
    u.searchParams.set('q',`collection:(${bandId}) AND mediatype:(etree OR audio)`);
    u.searchParams.append('fl[]','year');
    u.searchParams.set('rows',rows); u.searchParams.set('page',page); u.searchParams.set('output','json');
    u.searchParams.append('sort[]','date asc');
    return u.toString();
  },
  facetYearsJSONP({ bandId }){ /* ... */ return fetchJSONP(u.toString(), {timeout:12000}); },
  metaUrl:id=>`https://archive.org/metadata/${id}`,
  imgUrl:id=>`https://archive.org/services/img/${id}`,

  // NEW V1: shows in a band collection that happened on *-MM-DD (any year)
    onThisDayV1Url({ bandId, mm, dd, rows = 400, sort = 'date desc' }){
    const q = `collection:(${bandId}) AND (mediatype:(etree) OR mediatype:(audio)) AND date:*-${mm}-${dd}`;
    const u = new URL('https://archive.org/services/search/v1/scrape');
    u.searchParams.set('q', q);
    u.searchParams.set('count', String(rows));
    // ask v1 for the same fields we display
    u.searchParams.set('fields', [
      'identifier','title','date','year','downloads',
      'avg_rating','num_reviews','venue','coverage','creator','publicdate'
    ].join(','));
    // v1 uses space-separated sorts (you already map this elsewhere)
    u.searchParams.set('sorts', sort);
    return u.toString();
  },

  // NEW: shows in a band collection that happened on *-MM-DD (any year)
  onThisDayUrl({ bandId, mm, dd, rows=200, page=1, sort='date desc' }){
    const u = new URL('https://archive.org/advancedsearch.php');
    const q = `collection:(${bandId}) AND (mediatype:(etree) OR mediatype:(audio)) AND date:*-${mm}-${dd}`;
    u.searchParams.set('q', q);
    [
      'identifier','title','date','year','downloads',
      'avg_rating','num_reviews','venue','coverage','creator','publicdate'
    ].forEach(f => u.searchParams.append('fl[]', f));
    u.searchParams.append('sort[]', sort);
    u.searchParams.set('rows', rows);
    u.searchParams.set('page', page);
    u.searchParams.set('output', 'json');
    return u.toString();
  }
};


/* ------------ retry card ------------ */
function showRetry(contentEl, message, retryFn){
  contentEl.className='grid';
  contentEl.innerHTML = `
    <div class="card">
      <div class="retryWrap">
        <span class="small">${message}</span>
        <button class="btn" id="retryBtn">Retry</button>
      </div>
    </div>`;
  $('#retryBtn')?.addEventListener('click', retryFn);
}

/* ------------ SVG stars (full/half/empty) ------------ */
let _starUid = 0;
function starSVG(type){
  const id = 'g'+(++_starUid);
  if(type==='full'){
    return `<svg viewBox="0 0 24 24" width="14" height="14" aria-hidden="true">
      <path d="M12 2.3l2.9 5.9 6.6 1-4.8 4.7 1.1 6.6L12 17.8 6.2 20.5 7.3 13.9 2.5 9.2l6.6-1z" fill="#ffcc33" stroke="#ffcc33" stroke-width="1"/>
    </svg>`;
  }
  if(type==='half'){
    return `<svg viewBox="0 0 24 24" width="14" height="14" aria-hidden="true">
      <defs>
        <linearGradient id="${id}" x1="0" x2="1" y1="0" y2="0">
          <stop offset="50%" stop-color="#ffcc33"/>
          <stop offset="50%" stop-color="transparent"/>
        </linearGradient>
      </defs>
      <path d="M12 2.3l2.9 5.9 6.6 1-4.8 4.7 1.1 6.6L12 17.8 6.2 20.5 7.3 13.9 2.5 9.2l6.6-1z" fill="url(#${id})" stroke="#ffcc33" stroke-width="1"/>
    </svg>`;
  }
  return `<svg viewBox="0 0 24 24" width="14" height="14" aria-hidden="true">
    <path d="M12 2.3l2.9 5.9 6.6 1-4.8 4.7 1.1 6.6L12 17.8 6.2 20.5 7.3 13.9 2.5 9.2l6.6-1z" fill="none" stroke="#ffcc33" stroke-width="1"/>
  </svg>`;
}
function renderStars(r){
  const rating = Math.round((r||0)*2)/2;
  let out = '';
  for(let i=1;i<=5;i++){
    out += rating>=i ? starSVG('full') : (rating>=i-0.5 ? starSVG('half') : starSVG('empty'));
  }
  return `<span class="stars" aria-label="${rating} out of 5 stars">${out}</span>`;
}

/* ------------ Favorites helpers ------------ */
function favBands(){ return store.get('favBands',[]); }
function setFavBands(arr){ store.set('favBands',arr); }
function toggleFavBand(bandId){
  const arr=favBands(); const i=arr.indexOf(bandId);
  if(i>=0) arr.splice(i,1); else arr.push(bandId);
  setFavBands(arr); updateFavBandBtn();
}
function favShows(){ return store.get('favShows',[]); }
function isFavShow(id){ return favShows().includes(id); }
function toggleFavShow(id){ const fav=favShows(); const i=fav.indexOf(id); if(i>=0) fav.splice(i,1); else fav.push(id); store.set('favShows',fav); }

function favSongs(){ return store.get('favSongs',[]); } // array of {url,title,showId}
function findSongIdx(url){ return favSongs().findIndex(s=>s.url===url); }
function toggleFavSong(song){
  const arr=favSongs(); const i=arr.findIndex(s=>s.url===song.url);
  if(i>=0) arr.splice(i,1); else arr.push(song);
  store.set('favSongs',arr);
}
/* ------------ Recently Played helpers ------------ */  // NEW
function recentSongs(){ return store.get('recentSongs', []); }        // [{url,title,date,location,band,showTitle,ts}]
function pushRecent(song){                                            // keep list unique by url, newest first, max 100
  const arr = recentSongs();
  const i = arr.findIndex(s => s.url === song.url);
  if (i >= 0) arr.splice(i, 1);              // de-dupe
  arr.unshift({ ...song, ts: Date.now() });  // newest first
  if (arr.length > 100) arr.length = 100;    // cap at 100
  store.set('recentSongs', arr);
}
// Try to parse a show identifier from a track URL (https://archive.org/download/{showId}/{file})
function parseShowIdFromUrl(url = '') {
  try {
    const m = /archive\.org\/download\/([^/]+)\//i.exec(url);
    return m ? decodeURIComponent(m[1]) : '';
  } catch { return ''; }
}

function formatMDY(isoOrLocal = '') {
  // Reuse default locale formatting like other parts of the app
  try { return new Date(isoOrLocal).toLocaleDateString(); } catch { return ''; }
}

// Enrich a recent item in-place if it lacks metadata; also persist back to storage
async function enrichRecentItem(t) {
  if (t.band && t.location && t.date && t.showId) return t; // nothing to do

  const showId = t.showId || parseShowIdFromUrl(t.url);
  if (!showId) return t;

  try {
    const meta = await fetchIA(IA.metaUrl(showId));
    const md   = meta?.metadata || {};
    const date = md.date ? formatMDY(md.date) : (t.date || '');
    const venue = md.venue || '';
    const coverage = md.coverage || '';
    const location = [venue, coverage].filter(Boolean).join(', ') || t.location || '';
    const band = md.creator || t.band || '';
    const showTitle = md.title || t.showTitle || '';

    const enriched = { ...t, showId, date, location, band, showTitle };

    // Persist back to recentSongs (by URL)
    const arr = recentSongs();
    const idx = arr.findIndex(x => x.url === t.url);
    if (idx >= 0) {
      arr[idx] = enriched;
      store.set('recentSongs', arr);
    }
    return enriched;
  } catch {
    return t;
  }
}  
/* ------------ Bands page ------------ */
let onlyFavBands = false;
async function showBands(){
  show($('#toolbar-bands'),true); show($('#toolbar-band'),false); show($('#showMeta'),false);
  $('#subHeader').classList.remove('show');

  // Visual ON state
  $('#favToggle').classList.toggle('is-on', !!onlyFavBands);
  $('#favToggle').textContent = onlyFavBands ? '★ Favorites' : '☆ Favorites';

  const content=$('#content'); content.className='bandsGrid';

  // If filtering to favorite bands, render from local storage (fast, no network needed)
  if (onlyFavBands) {
    const fav = favBands();
    if (!fav.length) {
      content.innerHTML = `<div class="card"><span class="small">No favorite bands yet.</span></div>`;
      return;
    }
    content.innerHTML = fav.map(id=>{
      const title = decodeURIComponent(id).replace(/[_+]+/g,' ').trim();
      return `
        <div class="bandTile" data-id="${id}">
          <img src="${IA.imgUrl(id)}" alt="${title}">
          <div class="bandTitle">${title}</div>
          <div class="bandViews small">Favorited</div>
        </div>`;
    }).join('');
    content.onclick = ev => { const tile=ev.target.closest('.bandTile'); if(!tile) return; location.hash='#/band/'+encodeURIComponent(tile.dataset.id); };
    return;
  }

  // Otherwise, fetch and render all bands
  content.innerHTML=`<div class="card"><span class="small">Loading bands…</span></div>`;
  const sort=$('#sortSel')?.value||'downloads desc';
  const term=($('#searchBox')?.value||'').trim();
  let q='collection:(etree) AND mediatype:(collection)';
  if(term) q+=` AND (title:(${term}) OR identifier:(${term}))`;

  const load = async ()=>{
    try{
// Map UI sort ("downloads desc") → API sort ("downloads:desc")
// v1 likes title.raw for alpha sorts
function mapSortForV1(s = 'downloads desc') {
  const [field, dir = 'desc'] = s.split(/\s+/);
  // v1 uses `titleSorter` for alpha sorts
  const f = field === 'title' ? 'titleSorter' : field;
  const d = dir.toLowerCase();
  return `${f} ${d}`; // NOTE: space, not colon
}


const sortExpr = mapSortForV1(sort);
const params = new URLSearchParams({
  q,
  fields: 'identifier,title,downloads',
  sorts: sortExpr,          // <— plural
  count: '120'
});

const url = `https://archive.org/services/search/v1/scrape?${params.toString()}`;
const cacheKey = `bands:v1:${sortExpr}:${term || ''}`;      
// cache key should depend on sort + term to avoid stale mismatches
// ✨ use the resilient fetch with cache
const { data, stale } = await iaFetchJSON(url, {
  cacheKey,
  retries: 2,
  timeoutMs: 15000
});


// v1 returns { items: [...] }
const items = (data.items || []).map(d => ({
  id: d.identifier,
  title: d.title || d.identifier,
  downloads: d.downloads || 0
}));

if (stale) document.body.dataset.stale = '1'; // optional: mark UI as cached
      content.innerHTML = items.map(b=>`
        <div class="bandTile" data-id="${b.id}">
          <img src="${IA.imgUrl(b.id)}" alt="${b.title}">
          <div class="bandTitle">${b.title}</div>
          <div class="bandViews">${b.downloads.toLocaleString()} views</div>
        </div>`).join('');
      content.onclick = ev => { const tile=ev.target.closest('.bandTile'); if(!tile) return; location.hash='#/band/'+encodeURIComponent(tile.dataset.id); };
}catch(e){
  console.error('bands load failed:', e, { url });
  const msg = navigator.onLine ? 'Network error while loading bands.' : 'You appear to be offline.';
  showRetry(content, msg, load);
}


  };
  load();
}


/* ------------ Concerts page ------------ */
let currentBandId=''; 
let state={year:'', term:'', sortSel:'auto', page:1, numFound:0, rows:200, list:[]};
let onlyFavConcerts=false;

function isFav(id){ return favShows().includes(id); }
  
// Fetch favorite show docs for this band (batched), filtering by collection
async function fetchFavDocsForBand(bandId){
  const ids = favShows();
  if (!ids.length) return [];
  const batchSize = 40;
  let docs = [];
  for (let i=0; i<ids.length; i+=batchSize){
    const chunk = ids.slice(i, i+batchSize);
    const data = await fetchIA(IA.concertsByIdsUrl(chunk));
    const part = (data?.response?.docs) || [];
    docs = docs.concat(part);
  }
  // Keep only shows whose collections include this band id
  return docs.filter(d => Array.isArray(d.collection) ? d.collection.includes(bandId) : false);
}

/* Sort dropdown controller */
const SortDrop = (()=> {
  const wrap = document.getElementById('sortDrop');
  const btn  = document.getElementById('sortBtn');
  const menu = document.getElementById('sortMenu');
  let value = 'auto';
  const options = [
    {value:'auto', label:'Auto'},
    {value:'date asc', label:'Date ↑'},
    {value:'date desc', label:'Date ↓'},
    {value:'avg_rating desc', label:'Reviews ↓'},
    {value:'downloads desc', label:'Views ↓'},
  ];
  function render(){ menu.innerHTML = options.map(o=>`<div class="item" data-value="${o.value}">${o.label}</div>`).join(''); }
  function close(){ menu.classList.remove('open'); }
  wrap.addEventListener('click', (e)=>{ if(e.target.closest('.item')) return; menu.classList.toggle('open'); });
  document.addEventListener('click', (e)=>{ if(!wrap.contains(e.target)) close(); });
  menu.addEventListener('click', (e)=>{
    const it = e.target.closest('.item'); if(!it) return;
    setValue(it.dataset.value, false);
    close();
    onChange?.(value);
  });
  function setValue(v, placeholder=false){
    value = v||'auto';
    btn.textContent = placeholder && value==='auto' ? 'Sort'
      : (options.find(o=>o.value===value)?.label || 'Sort');
    state.sortSel=value;
  }
  let onChange = null;
  function subscribe(fn){ onChange = fn; }
  render(); setValue('auto', true);
  return {getValue:()=>value, setValue, subscribe};
})();

/* Year dropdown controller */
const YearDrop = (()=> {
  const wrap = document.getElementById('yearDrop');
  const btn  = document.getElementById('yearBtn');
  const menu = document.getElementById('yearMenu');
  let value = '';
  let options = [{value:'', label:'All years'}];
  function render(){ menu.innerHTML = options.map(o=>`<div class="item" data-value="${o.value}">${o.label}</div>`).join(''); }
  function close(){ menu.classList.remove('open'); }
  wrap.addEventListener('click', (e)=>{ if(e.target.closest('.item')) return; menu.classList.toggle('open'); });
  document.addEventListener('click', (e)=>{ if(!wrap.contains(e.target)) close(); });
  menu.addEventListener('click', (e)=>{
    const it = e.target.closest('.item'); if(!it) return;
    value = it.dataset.value || '';
    btn.textContent = (options.find(o=>String(o.value)===String(value))?.label) || 'All years';
    close();
    resetAndLoad({year:value});
  });
  function setOptions(arr){ options = arr; render(); }
  function setValue(v){ value=v||''; btn.textContent=(options.find(o=>String(o.value)===String(value))?.label)||'All years'; }
  function getValue(){ return value; }
  render();
  return {setOptions,setValue,getValue};
})();

function resolveSort(){ return state.sortSel==='auto' ? (state.year ? 'date asc' : 'date desc') : state.sortSel; }

async function buildYearCounts(bandId){
  // First try the official facet endpoint via JSONP (CORS-safe)
  const facet = await IA.facetYearsJSONP({bandId});
  let counts = {};
  if (facet?.response?.facets?.year){
    const y = facet.response.facets.year;
    for (const k in y){
      const yr = Number(k);
      if (!Number.isNaN(yr)) counts[yr] = (counts[yr] || 0) + Number(y[k] || 0);
    }
  }

  // If we didn’t get anything, don’t fall back to paged fetch (CORS trap).
  // Just leave “All years” and let the concerts list work normally.
  if (!Object.keys(counts).length){
    YearDrop.setOptions([{value:'', label:'All years'}]);
    YearDrop.setValue('');
    return;
  }

  updateYearMenu(counts);

  const yearsArr = Object.keys(counts)
    .map(y=>({year:Number(y), count:counts[y]}))
    .filter(o=>!Number.isNaN(o.year))
    .sort((a,b)=>a.year-b.year);

  store.set('years_'+bandId, {ts: Date.now(), years: yearsArr});
}

function updateYearMenu(counts){
  const yearsArr = Object.keys(counts)
    .map(y=>({year:Number(y), count:counts[y]}))
    .filter(o=>!Number.isNaN(o.year))
    .sort((a,b)=>a.year-b.year);

  YearDrop.setOptions([
    {value:'', label:'All years'},
    ...yearsArr.map(o=>({value:String(o.year), label:`${o.year} (${o.count.toLocaleString()})`}))
  ]);
  YearDrop.setValue(YearDrop.getValue());
}

async function loadPage(){
  const content=$('#content');
  const sortExpr = resolveSort();
  const url = IA.concertsUrl({bandId:currentBandId, sort:sortExpr, rows:state.rows, page:state.page, year:state.year, term:state.term});
try{
  const cacheKey = `concerts:${currentBandId}:${state.year}:${state.term}:${sortExpr}:p${state.page}`;
  const { data, stale } = await iaFetchJSON(url, {
    cacheKey,
    retries: 2,
    timeoutMs: 15000
  });

  if (stale) document.body.dataset.stale = '1'; // optional: tag UI as using cache

  const resp = data?.response || {};
  state.numFound = Number(resp.numFound || 0);
  state.list = state.list.concat(resp.docs || []);
  renderConcerts();
}catch(e){
  showRetry(content, 'Network error while loading concerts.', ()=>loadPage());
}

}

function resetAndLoad(patch={}){
  state = { ...state, ...patch, page:1, list:[], numFound:0 };
  const content=$('#content'); content.className='grid'; content.innerHTML=`<div class="card"><span class="small">Loading concerts…</span></div>`;
  loadPage();
}

async function showBand(params){
  show($('#toolbar-bands'),false); show($('#toolbar-band'),true); show($('#showMeta'),false);
  currentBandId = decodeURIComponent((params||[])[0]||'');
  // Show band name from id (spaces preserved from IA titles rendered later from list cache best-effort)
const prettyBand = decodeURIComponent(currentBandId)
  .replace(/[_+]+/g, ' ')           // underscores/plus → space
  .replace(/([a-z])([A-Z])/g, '$1 $2') // camelCase → spaced
  .replace(/\s+/g, ' ')
  .trim();
$('#bandName').textContent = prettyBand;
  // Fav band button
  $('#favBandBtn').onclick = ()=> toggleFavBand(currentBandId);
  updateFavBandBtn();

  // Sort dropdown wiring
  SortDrop.subscribe((val)=> resetAndLoad({sortSel:val}));
  SortDrop.setValue('auto', true);

  // Visual ON state for favorites toggle
  $('#favConcertsToggle').classList.toggle('is-on', !!onlyFavConcerts);
  $('#favConcertsToggle').textContent = onlyFavConcerts ? '★ Favorites' : '☆ Favorites';

  $('#favConcertsToggle').onclick=()=>{
    onlyFavConcerts=!onlyFavConcerts;
    $('#favConcertsToggle').textContent = onlyFavConcerts?'★ Favorites':'☆ Favorites';
    $('#favConcertsToggle').classList.toggle('is-on', !!onlyFavConcerts);
    renderConcerts();
  };
  $('#resetConcerts').onclick=()=>{
    onlyFavConcerts=false; YearDrop.setValue(''); $('#concertSearch').value='';
    SortDrop.setValue('auto', true);
    $('#favConcertsToggle').textContent='☆ Favorites';
    $('#favConcertsToggle').classList.remove('is-on');
    resetAndLoad({year:'', term:'', sortSel:'auto'});
  };
  $('#concertSearch').onchange=()=> resetAndLoad({term:($('#concertSearch').value||'').trim().toLowerCase()});

  const cached = store.get('years_'+currentBandId,null);
  if(cached){ const counts={}; for(const y of cached.years) counts[y.year]=y.count; updateYearMenu(counts); }
  else { YearDrop.setOptions([{value:'', label:'All years'}, {value:'', label:'Loading years…'}]); }
  buildYearCounts(currentBandId).catch(()=>{});

  resetAndLoad({year:'', term:'', sortSel:'auto'});
}
function updateFavBandBtn(){
  const btn=$('#favBandBtn'); if(!btn) return;
  const isFav = favBands().includes(currentBandId);
  btn.textContent = isFav ? '★' : '☆';
  btn.classList.toggle('fav', isFav);
}
async function renderFavConcertsForBand(){
  const content = $('#content'); 
  content.className = 'grid';
  const docs = await fetchFavDocsForBand(currentBandId);

  if (!docs.length){
    content.innerHTML = `<div class="card"><span class="small">No favorite concerts for this band.</span></div>`;
    return;
  }

  content.innerHTML = docs.map(it=>{
    const dateStr   = it.date ? new Date(it.date).toLocaleDateString() : (it.year||'');
    const reviews   = it.num_reviews || 0;
    const venueLine = [it.venue, it.coverage].filter(Boolean).join(', ');
    const viewsChip = `<span class="chip">${fmtCompact(it.downloads||0)} views</span>`;
    return `
      <div class="card tap" data-id="${it.identifier}">
        <div>
          <h3>${it.title || it.identifier}</h3>
          <div class="row">
            <span class="chip">${dateStr}</span>
            ${viewsChip}
            ${renderStars(it.avg_rating||0)} <span class="small">(${reviews})</span>
          </div>
          <div class="small">${venueLine}</div>
        </div>
        <div class="row">
<button class="btn ghost favToggle${isFav(it.identifier) ? ' is-on' : ''}" title="Favorite">
  ${isFav(it.identifier) ? '★' : '☆'}
</button>

        </div>
      </div>`;
  }).join('');

  // Clicks (open / unfavorite)
content.onclick = ev => {
  const favBtn = ev.target.closest('.favToggle');
  if (favBtn){
    const card = favBtn.closest('.card'); const id = card.dataset.id;
    toggleFavShow(id); renderConcerts();
    return;
  }

  const card = ev.target.closest('.card.tap');
  if (card) {
    // remember the origin so the Show header can offer “← Concerts”
    store.set('cameFrom', 'band');
    store.set('cameFromBandId', currentBandId || '');
    location.hash = '#/show/' + encodeURIComponent(card.dataset.id);
  }
};

}

function renderConcerts(){
  const content=$('#content'); if(!content) return;
  let list=state.list.slice();
  if(onlyFavConcerts){ const fav=favShows(); list=list.filter(d=>fav.includes(d.identifier)); }

  if(!list.length){ content.innerHTML=`<div class="card"><span class="small">No concerts found.</span></div>`; return; }

  content.innerHTML = list.map(it=>{
    const dateStr = it.date ? new Date(it.date).toLocaleDateString() : (it.year||'');
    const reviews = it.num_reviews||0;
    const venueLine = [it.venue, it.coverage].filter(Boolean).join(', ');
    const viewsChip = `<span class="chip">${fmtCompact(it.downloads||0)} views</span>`;
    return `
      <div class="card tap" data-id="${it.identifier}">
        <div>
          <h3>${it.title || it.identifier}</h3>
          <div class="row">
            <span class="chip">${dateStr}</span>
            ${viewsChip}
            ${renderStars(it.avg_rating||0)} <span class="small">(${reviews})</span>
          </div>
          <div class="small">${venueLine}</div>
        </div>
        <div class="row">
         <button class="btn ghost favToggle${isFav(it.identifier) ? ' is-on' : ''}" title="Favorite">
  ${isFav(it.identifier) ? '★' : '☆'}
</button>

        </div>
      </div>`;
  }).join('');

  if(!onlyFavConcerts && state.list.length < state.numFound){
    const more = document.createElement('div');
    more.className='card loadMore';
    more.innerHTML = `<button class="btn" id="loadMoreBtn">Load more (${state.list.length} / ${state.numFound})</button>`;
    content.appendChild(more);
    $('#loadMoreBtn').onclick = ()=>{ state.page += 1; loadPage(); };
  }

content.onclick = ev => {
  const favBtn = ev.target.closest('.favToggle');
  if (favBtn){
    const card = favBtn.closest('.card'); const id = card ? card.dataset.id : null;
    if (id){ toggleFavShow(id); renderFavConcertsForBand(); }
    return;
  }

  const card = ev.target.closest('.card.tap');
  if (card){
    store.set('cameFrom', 'band');
    store.set('cameFromBandId', currentBandId || '');
    location.hash = '#/show/' + encodeURIComponent(card.dataset.id);
  }
};

}

/* ------------ Show (tracks) ------------ */
let currentShowId=''; let currentShowTitle=''; let trackEls=[]; let trackList=[];

function updateFavBtn(){ const btn=$('#favShowBtn'); if(!btn) return; const fav = favShows().includes(currentShowId); btn.textContent = fav ? '★ Favorited' : '☆ Favorite'; btn.classList.toggle('fav', fav); }
// add globals to hold current show meta (place near other globals)
let currentShowDate = '';
let currentShowLocation = '';
let currentShowBand = '';      // <-- NEW


function setShowHeader(meta){
  const title = meta?.metadata?.title || currentShowId;

  const date  = meta?.metadata?.date || '';
  const venue = meta?.metadata?.venue || '';
  const coverage = meta?.metadata?.coverage || '';
  const location = [venue, coverage].filter(Boolean).join(', ');

  // NEW: capture band/artist and store globally
  const band = meta?.metadata?.creator || '';
  currentShowBand = band;

  currentShowTitle    = title;
  currentShowDate     = date ? new Date(date).toLocaleDateString() : '';
  currentShowLocation = location;

  $('#showTitle').textContent = title; show($('#showMeta'),true);
  if(date){ $('#showDate').textContent = currentShowDate; show($('#showDate'),true);} else show($('#showDate'),false);
  if(location){ $('#showLoc').textContent = location; show($('#showLoc'),true);} else show($('#showLoc'),false);
}
  
function cleanTitle(name){ let t=name.replace(/\.(mp3|ogg|flac)$/i,''); t=t.replace(/[_-]+/g,' ').replace(/\s+/g,' ').trim(); t=t.replace(/^(\d+)[\s.\-_]+/,''); return t; }
function naturalCmp(a,b){ return a.localeCompare(b,undefined,{numeric:true,sensitivity:'base'}); }
function extractTrackNo(f){ const n1=Number(f.track||f.trackno||''); if(!isNaN(n1)&&n1>0) return n1; const m=/(\d+)[^\d]*\.(mp3|ogg|flac)$/i.exec(f.name||''); if(m) return Number(m[1]); return Infinity; }

async function showShow(params){
  show($('#toolbar-bands'),false); show($('#toolbar-band'),false);
  currentShowId = decodeURIComponent((params||[])[0]||'');

  const content=$('#content'); content.className='tracks'; content.innerHTML=`<div class="card"><span class="small">Loading tracks…</span></div>`;
  const load = async ()=>{
    try{
      const meta = await fetchIA(IA.metaUrl(currentShowId));
      setShowHeader(meta);
      $('#favShowBtn').onclick = () => { toggleFavShow(currentShowId); updateFavBtn(); };
      updateFavBtn();

      const files = meta?.files||[];
      let playable = files.filter(f => /\.mp3$/i.test(f.name||'') || (f.format||'').toLowerCase().includes('mp3'));
      if (playable.length===0){ playable = files.filter(f => /\.(ogg|flac)$/i.test(f.name||'') || /(ogg|flac)/.test((f.format||'').toLowerCase())); }

      playable.sort((a,b)=>{ const an=extractTrackNo(a), bn=extractTrackNo(b); if (an!==bn) return an-bn; return naturalCmp(a.name||'', b.name||''); });

      const seen=new Set(); trackList=[];
      for (const f of playable){
        const title = cleanTitle(f.title || f.name || '');
        const key = title.toLowerCase(); if (seen.has(key)) continue; seen.add(key);
        const url = `https://archive.org/download/${currentShowId}/${encodeURIComponent(f.name)}`;
        trackList.push({ url, title, length: f.length || '' });
      }

      if (!trackList.length){ content.innerHTML=`<div class="card"><span class="small">No playable files found.</span></div>`; return; }

      content.innerHTML = trackList.map((t,i)=>`
        <div class="track" data-i="${i}">
          <div class="tleft">
<button class="songFav${ findSongIdx(t.url)>=0 ? ' is-on' : '' }" title="Favorite song">
  ${ findSongIdx(t.url)>=0 ? '★' : '☆' }
</button>
            <div class="tnum">${i+1}</div>
            <div class="tname">${t.title}</div>
          </div>
          <div class="tlen">${t.length}</div>
          <div class="progressBar" id="pb-${i}"></div>
        </div>`).join('');

      trackEls = $$('.track');
// If we arrived via the Now-Playing button, jump to the exact track in this show
const jumpUrl = store.get('jumpToUrl', null);
if (jumpUrl) {
  store.set('jumpToUrl', null); // one-time use
  const idx = trackList.findIndex(t => t.url === jumpUrl);
  if (idx >= 0) {
    // Sync highlight with what's playing
    curIndex = idx;
    updateTrackHighlight();

    // Scroll into view and pulse for visibility
    const el = document.querySelector(`.track[data-i="${idx}"]`);
    if (el) {
      el.scrollIntoView({ block: 'center', behavior: 'smooth' });
      el.classList.add('pulse');
      setTimeout(() => el.classList.remove('pulse'), 1800);
    }
  }
}

      

content.onclick = ev => {
  const favBtn = ev.target.closest('.songFav');
  if (favBtn) {
    const tr = ev.target.closest('.track'); 
    if (!tr) return;
    const idx = Number(tr.dataset.i);
    const song = {
      ...trackList[idx],
      showId: currentShowId,
      date: currentShowDate,
      location: currentShowLocation,
      band: currentShowBand,      // NEW
      showTitle: currentShowTitle // NEW
    };
    toggleFavSong(song);
    favBtn.textContent = findSongIdx(song.url) >= 0 ? '★' : '☆';
    favBtn.classList.toggle('is-on', findSongIdx(song.url) >= 0);

    return;
  }
  const tr = ev.target.closest('.track'); 
  if (!tr) return;
  playIndex(Number(tr.dataset.i));
};

      // Autoplay if flagged (used by concert queue)
      const pending = store.get('autoPlayOnLoad', false);
      if (pending){ store.set('autoPlayOnLoad', false); playIndex(0); }

    }catch(e){
      const msg = navigator.onLine ? 'Network error while loading tracks.' : 'You appear to be offline.';
      showRetry(content, msg, load);
    }
  };
  load();
}

/* ------------ Player, Queues & Media Session ------------ */
const A=$('#audio');
const P={ play:$('#P_play'), prev:$('#P_prev'), next:$('#P_next'), mute:$('#P_mute'), seek:$('#P_seek'), cur:$('#P_times .cur'), dur:$('#P_times .dur') };
const P_now = $('#P_now');
const volPop = $('#volPop'); const P_vol = $('#P_vol'); const volLabel = $('#volLabel');

let queue=[]; let curIndex=-1;

/* Show queue for Favorites → Concerts "Play All" / "Shuffle All" */
let showQueue = store.get('showQueue', []); // array of show identifiers
let showQueuePos = store.get('showQueuePos', -1);
let queueShowsActive = store.get('queueShowsActive', false);
let playlistMeta = null; // parallel to queue/trackList when playing from "Recent"
  
function persistShowQueue(){
  store.set('showQueue', showQueue);
  store.set('showQueuePos', showQueuePos);
  store.set('queueShowsActive', queueShowsActive);
}

function setQueueFromTracks(){ queue = trackList.map(t=>t.url); }
// Find this code: function updateMediaSession(
function updateMediaSession(title = 'Playing') {
  if (!('mediaSession' in navigator)) return;

  const artist = currentShowBand || 'Setlist Streamer';
  const album  = [currentShowLocation, currentShowDate].filter(Boolean).join(' • ');

  try {
    navigator.mediaSession.metadata = new MediaMetadata({
      title,
      artist,        // band
      album,         // "Venue/City • MM/DD/YYYY"
      artwork: [
        { src: 'icons/logo-96.png?v=3',  sizes: '96x96',  type: 'image/png' },
        { src: 'icons/logo-192.png?v=3', sizes: '192x192', type: 'image/png' },
        { src: 'icons/logo-512.png?v=3', sizes: '512x512', type: 'image/png' }
      ]
    });

    // keep Android’s scrubber in sync (best-effort)
    try {
      navigator.mediaSession.setPositionState({
        duration:    Number.isFinite(A.duration) ? A.duration : 0,
        playbackRate: A.playbackRate || 1,
        position:    Number.isFinite(A.currentTime) ? A.currentTime : 0
      });
    } catch (_) {}
  } catch (_) {}
}

function playIndex(i){
  if(!trackList.length) return;
  setQueueFromTracks();
  curIndex=Math.max(0,Math.min(i,queue.length-1));
if (Array.isArray(playlistMeta) && playlistMeta.length === trackList.length) { // tightened
  const m = playlistMeta[curIndex];
  if (m) {
    currentShowDate     = m.date || '';
    currentShowLocation = m.location || '';
    currentShowBand     = m.band || '';
    currentShowTitle    = m.showTitle || m.title || '';
    if (m.showId) currentShowId = m.showId;
  }
}
  
  // Log to Recently Played (uses current show metadata)  // NEW
try {
  const t = trackList[curIndex];
  if (t && t.url) {
pushRecent({
  url: t.url,
  title: t.title,
  date: currentShowDate || '',
  location: currentShowLocation || '',
  band: currentShowBand || '',
  showTitle: currentShowTitle || '',
  showId: currentShowId || ''
});

  }
} catch(e) {}
  A.src=queue[curIndex];
  updateMediaSession(trackList[curIndex]?.title || 'Track');
  A.play().catch(()=>{});
  updateTrackHighlight();
  store.set('currentShowId', currentShowId);
  updateEqAnim();
}
function updateTrackHighlight(){ trackEls.forEach((el,idx)=>el.classList.toggle('playing', idx===curIndex)); }
P.play?.addEventListener('click', ()=>{ if(A.paused) A.play(); else A.pause(); });

/* Equalizer animation state */
const EQ = document.querySelector('#P_now .eqBars');
function updateEqAnim(){ if(EQ) EQ.classList.toggle('paused', A.paused); }
A.addEventListener('play',  ()=>{ P.play.textContent='⏸'; store.set('wasPlaying', true); updateEqAnim(); });
A.addEventListener('pause', ()=>{ P.play.textContent='▶️'; store.set('wasPlaying', false); updateEqAnim(); });

A.addEventListener('ended', ()=>{
  updateEqAnim();
  if(curIndex<queue.length-1){
    // Advance within current show/playlist
    playIndex(curIndex+1);
  }else{
    // End of current list — if a show queue is active, advance to next show
    if(queueShowsActive && showQueuePos >=0 && showQueuePos < showQueue.length-1){
      showQueuePos += 1; persistShowQueue();
      const nextShowId = showQueue[showQueuePos];
      store.set('autoPlayOnLoad', true);
      location.hash = '#/show/' + encodeURIComponent(nextShowId);
    }else{
      // Reached the end of everything
      queueShowsActive = false; persistShowQueue();
    }
  }
});

P.prev?.addEventListener('click', ()=>{ if(curIndex>0) playIndex(curIndex-1); });
P.next?.addEventListener('click', ()=>{ if(curIndex<queue.length-1) playIndex(curIndex+1); });

/* Volume controls */
function setVolumeUI(v){
  const pct = Math.round((v||0)*100);
  volLabel.textContent = pct+'%';
  P_mute.textContent = (A.muted || v===0) ? '🔇' : '🔈';
}
const P_mute = $('#P_mute');
const savedVol = Number(store.get('volume', 1));
A.volume = isNaN(savedVol)?1:Math.max(0,Math.min(1,savedVol));
P_vol.value = String(A.volume);
setVolumeUI(A.volume);

P_mute.addEventListener('click', ()=>{ volPop.classList.toggle('open'); });
document.addEventListener('click',(e)=>{
  const w = $('.volWrap');
  if(!w.contains(e.target)) volPop.classList.remove('open');
});
P_vol.addEventListener('input', ()=>{
  const v = Number(P_vol.value);
  A.volume = Math.max(0,Math.min(1,v));
  A.muted = (A.volume===0);
  store.set('volume', A.volume);
  setVolumeUI(A.volume);
});

/* Seek & time */
P.seek?.addEventListener('input', ()=>{ if(!A.duration||isNaN(A.duration)) return; A.currentTime=(P.seek.value/1000)*A.duration; });
A.addEventListener('timeupdate', ()=>{
  if(A.duration&&!isNaN(A.duration)){
    P.cur.textContent=fmtTime(A.currentTime); P.dur.textContent=' / '+fmtTime(A.duration); P.seek.value=Math.floor((A.currentTime/A.duration)*1000);
    if(curIndex>=0){ const pb=$('#pb-'+curIndex); if(pb) pb.style.width=`${(A.currentTime/A.duration)*100}%`; }
  }else{ P.cur.textContent='0:00'; P.dur.textContent=' / 0:00'; P.seek.value=0; }
});

/* Equalizer button -> jump back to current show */
P_now.addEventListener('click', () => {
  const id  = store.get('currentShowId', null) || currentShowId;
  const url = (trackList[curIndex] && trackList[curIndex].url) || '';
  if (id) {
    if (url) store.set('jumpToUrl', url);   // remember the exact track
    location.hash = '#/show/' + encodeURIComponent(id);
  }
});


/* Auto-resume */
function markHideState(){ store.set('wasPlayingOnHide', !A.paused); }
function tryAutoResume(){
  if (store.get('wasPlayingOnHide', false)){
    A.play().catch(()=>{ /* autoplay block ignored */ });
  }
}
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden) markHideState(); else tryAutoResume();
});
window.addEventListener('pageshow', tryAutoResume);
window.addEventListener('focus', tryAutoResume);
if (navigator.mediaDevices && 'ondevicechange' in navigator.mediaDevices){
  navigator.mediaDevices.ondevicechange = () => { tryAutoResume(); };
}

async function fetchOnThisDayForBand(bandId, mm, dd){
  // 1) Try advancedsearch.php
  const advUrl   = IA.onThisDayUrl({ bandId, mm, dd, rows: 400, sort: 'date desc' });
  const advKey   = `onthisday:adv:${bandId}:${mm}-${dd}`;
  let advDocs    = [];
  try{
    const { data } = await iaFetchJSON(advUrl, { cacheKey: advKey, retries: 2, timeoutMs: 15000 });
    advDocs = data?.response?.docs || [];
  }catch(_){ /* fall through to v1 */ }

  // 2) If nothing came back, try v1 “scrape”
  let docs = advDocs;
  if (!docs.length){
    const v1Url = IA.onThisDayV1Url({ bandId, mm, dd, rows: 400, sort: 'date desc' });
    const v1Key = `onthisday:v1:${bandId}:${mm}-${dd}`;
    try{
      const { data } = await iaFetchJSON(v1Url, { cacheKey: v1Key, retries: 2, timeoutMs: 15000 });
      docs = (data?.items) || [];
    }catch(_){ /* leave docs as-is */ }
  }

  // Normalize both shapes to a common object
  return docs.map(it => ({
    id: it.identifier,
    title: it.title || it.identifier,
    date: it.date || it.publicdate || '',
    year: it.year || (it.date ? String(it.date).slice(0,4) : ''),
    downloads: it.downloads || 0,
    rating: it.avg_rating || 0,
    reviews: it.num_reviews || 0,
    venue: it.venue || '',
    coverage: it.coverage || '',
    band: it.creator || decodeURIComponent(bandId).replace(/[_+]+/g,' ').trim()
  }));
}


async function loadOnThisDayAllFavs(){
  const favs = favBands();      // array of bandId collections (e.g., gratefuldead)
  if (!favs.length) return [];
  const { mm, dd } = todayMMDD();

  const all = [];
  for (const id of favs){
    try{
      const rows = await fetchOnThisDayForBand(id, mm, dd);
      all.push(...rows);
    }catch(e){
      console.warn('onthisday failed for', id, e);
    }
  }
  // newest first, then downloads as tiebreaker
  all.sort((a,b) => (String(b.year).localeCompare(String(a.year)) || (b.downloads - a.downloads)));
  return all;
}

async function showOnThisDay(){
  // Hide toolbars and show a clean list view
  show($('#toolbar-bands'), false);
  show($('#toolbar-band'), false);
  show($('#showMeta'), false);
  $('#subHeader').classList.remove('show');

  const content = $('#content');
  content.className = 'grid';
  content.innerHTML = `<div class="card"><span class="small">Loading shows for this date…</span></div>`;
  
  const rows = await loadOnThisDayAllFavs();

  if (!rows.length){
    content.innerHTML = `<div class="card"><span class="small">No shows found for your favorite bands on this date.</span></div>`;
    return;
  }

  content.innerHTML = rows.map(it => {
    const dateStr   = it.date ? new Date(it.date).toLocaleDateString() : (it.year || '');
    const venueLine = [it.venue, it.coverage].filter(Boolean).join(', ');
    const viewsChip = `<span class="chip">${fmtCompact(it.downloads)} views</span>`;
    const stars     = renderStars(it.rating);
    return `
      <div class="card tap" data-id="${it.id}">
        <div>
          <h3>${it.title}</h3>
          <div class="row">
            <span class="chip">${dateStr}</span>
            <span class="chip">${it.band}</span>
            ${viewsChip}
            ${stars} <span class="small">(${it.reviews})</span>
          </div>
          <div class="small">${venueLine}</div>
        </div>
        <div class="row">
          <button class="btn ghost favToggle${ isFav(it.id) ? ' is-on' : '' }" title="Favorite">
            ${ isFav(it.id) ? '★' : '☆' }
          </button>
        </div>
      </div>
    `;
  }).join('');

  // open show / toggle favorite
  content.onclick = (e) => {
    const favBtn = e.target.closest('.favToggle');
    if (favBtn){
      const card = favBtn.closest('.card'); const id = card?.dataset.id;
      if (!id) return;
      toggleFavShow(id);
      favBtn.classList.toggle('is-on', isFav(id));
      favBtn.textContent = isFav(id) ? '★' : '☆';
      return;
    }

    const card = e.target.closest('.card.tap');
    if (card){
      store.set('cameFrom', 'onthisday');
      location.hash = '#/show/' + encodeURIComponent(card.dataset.id);
    }
  };
}

  
/* ------------ Favorites pages ------------ */
Router.on('favorites', (params)=>{ location.hash = '#/favorites/bands'; });
Router.on('fav', (params)=>{ location.hash = '#/favorites/bands'; });

Router.on('favorites/bands', ()=>{
  show($('#toolbar-bands'),false); show($('#toolbar-band'),false); show($('#showMeta'),false);
  const content=$('#content'); content.className='grid';
  const bands = favBands();
  if(!bands.length){ content.innerHTML = `<div class="card"><span class="small">No favorite bands yet.</span></div>`; return; }
content.innerHTML = bands.map(id=>
  `<div class="card fav">
    <div class="row">
      <img src="${IA.imgUrl(id)}" alt="" style="width:42px;height:42px;border-radius:8px;object-fit:cover;background:#0c0c0d;border:1px solid var(--ring)">
      <div>
        <div class="title" style="font-weight:600">${decodeURIComponent(id).replace(/[_+]+/g,' ').trim()}</div>
        <div class="small">${id}</div>
      </div>
    </div>
    <div class="row">
      <button class="btn" data-go="#/band/${encodeURIComponent(id)}">Open</button>
      <button class="btn ghost is-on" data-unfav="${id}" title="Remove">★</button>
    </div>
  </div>`
).join('');

  content.onclick = (e)=>{
    const go = e.target.getAttribute('data-go'); if(go){ location.hash=go; return; }
    const unf = e.target.getAttribute('data-unfav'); if(unf){
      toggleFavBand(unf); Router.route(); return;
    }
  };
});
/* ------------ Recently Played page ------------ */  // NEW
Router.on('recent', () => {
  show($('#toolbar-bands'),false); show($('#toolbar-band'),false); show($('#showMeta'),false);
  const content = $('#content'); content.className = 'tracks';
  const songs = recentSongs();

  // Actions
  const actions = document.createElement('div');
  actions.className = 'pageActions';
  actions.innerHTML = `
    <button class="btn" id="recentPlayAll">▶️ Play All</button>
    <button class="btn" id="recentShuffleAll">🔀 Shuffle All</button>
  `;
  content.innerHTML = '';
  content.appendChild(actions);

  if (!songs.length){
    const empty = document.createElement('div');
    empty.className='card'; empty.innerHTML=`<span class="small">No recent plays yet.</span>`;
    content.appendChild(empty);
    return;
  }

  // List (reuse the .track.favsong two-line layout)
  const listWrap = document.createElement('div');
  listWrap.className='tracks';
  listWrap.style.padding='0 12px 120px';
  listWrap.innerHTML = songs.map((t,i)=>`
    <div class="track favsong" data-i="${i}">
      <div class="line1">
        <div class="tleft">
<button class="songFav${ findSongIdx(t.url)>=0 ? ' is-on' : '' }" title="${findSongIdx(t.url)>=0 ? 'Unfavorite' : 'Favorite'}">
  ${ findSongIdx(t.url)>=0 ? '★' : '☆' }
</button>

          <div class="tnum">${i+1}</div>
          <div class="tname">${t.title}</div>
        </div>
        ${t.band ? `<span class="pill pill-sm bandpill">${t.band}</span>` : ''}
      </div>

      <div class="line2">
        ${t.location ? (
  t.showId
    ? `<a class="pill pill-sm locpill" href="#/show/${encodeURIComponent(t.showId)}">${t.location}</a>`
    : `<span class="pill pill-sm locpill">${t.location}</span>`
) : ''}

        ${t.date ? `<span class="pill pill-sm datepill">${t.date}</span>` : ''}
      </div>

      <div class="progressBar"></div>
    </div>
  `).join('');
  content.appendChild(listWrap);

  // After initial render, backfill old rows that are missing metadata and update DOM
  (async () => {
    for (let i = 0; i < songs.length; i++) {
      const t = songs[i];
      if (t.band && t.location && t.date && t.showId) continue;

      const enriched = await enrichRecentItem(t);
      if (!enriched) continue;

      const row = listWrap.querySelector(`.track[data-i="${i}"]`);
      if (!row) continue;

      const line1 = row.querySelector('.line1');
      if (line1) {
        let bandEl = line1.querySelector('.bandpill');
        if (!bandEl) {
          bandEl = document.createElement('span');
          bandEl.className = 'pill pill-sm bandpill';
          line1.appendChild(bandEl);
        }
        bandEl.textContent = enriched.band || '';
        bandEl.style.display = enriched.band ? '' : 'none';
      }

      const line2 = row.querySelector('.line2');
      if (line2) {
        let locEl = line2.querySelector('.locpill');
        const href = enriched.showId ? `#/show/${encodeURIComponent(enriched.showId)}` : '';
        if (!locEl) {
          if (href) {
            locEl = document.createElement('a');
            locEl.className = 'pill pill-sm locpill';
            locEl.setAttribute('href', href);
          } else {
            locEl = document.createElement('span');
            locEl.className = 'pill pill-sm locpill';
          }
          line2.prepend(locEl);
        } else {
          if (href && locEl.tagName !== 'A') {
            const replacement = document.createElement('a');
            replacement.className = locEl.className;
            replacement.textContent = locEl.textContent;
            replacement.setAttribute('href', href);
            locEl.replaceWith(replacement);
            locEl = replacement;
          } else if (!href && locEl.tagName === 'A') {
            const replacement = document.createElement('span');
            replacement.className = locEl.className;
            replacement.textContent = locEl.textContent;
            locEl.replaceWith(replacement);
            locEl = replacement;
          }
        }
        locEl.textContent = enriched.location || '';
        locEl.style.display = enriched.location ? '' : 'none';

        let dateEl = line2.querySelector('.datepill');
        if (!dateEl) {
          dateEl = document.createElement('span');
          dateEl.className = 'pill pill-sm datepill';
          line2.appendChild(dateEl);
        }
        dateEl.textContent = enriched.date || '';
        dateEl.style.display = enriched.date ? '' : 'none';
      }

      songs[i] = enriched;
    }
  })();

  trackEls = Array.from(listWrap.querySelectorAll('.track'));

  // Play All / Shuffle All
  $('#recentPlayAll').onclick   = ()=> startRecent(false);
  $('#recentShuffleAll').onclick= ()=> startRecent(true);

  function startRecent(shuffle){
    const arr = songs.slice();
    if (shuffle) shuffleArray(arr);
    playlistMeta = arr;
    currentShowId = arr[0]?.showId || 'recent_playlist';
    trackList = arr.map(t => ({ url: t.url, title: t.title, length: '' }));
    playIndex(0);
  }

  function showLabel(show){
    const loc = [show.city, show.state].filter(Boolean).join(', ');
    return [show.venue || loc || 'Live', show.date].filter(Boolean).join(' • ');
  }

  // Item interactions (favorite toggle / play single)
  listWrap.onclick = (e) => {
    // If user clicks a location link to a concert, mark origin so Show header says "← Recently Played"
    const concertLink = e.target.closest('a[href^="#/show/"]');
    if (concertLink) {
      store.set('cameFrom', 'recent');
      // Optional: remember exact track for scroll-into-view (mirrors Favorites → Songs)
      const row = e.target.closest('.track');
      if (row) {
        const i = Number(row.dataset.i);
        const t = songs[i];
        if (t?.url) store.set('jumpToUrl', t.url);
      }
      return; // allow navigation
    }

    const tr = e.target.closest('.track'); if (!tr) return;
    const i = Number(tr.dataset.i);
    const t = songs[i];

    if (e.target.closest('.songFav')) {
      toggleFavSong(t);
      e.target.textContent = findSongIdx(t.url) >= 0 ? '★' : '☆';
      e.target.classList.toggle('is-on', findSongIdx(t.url) >= 0);
      e.target.title = findSongIdx(t.url) >= 0 ? 'Unfavorite' : 'Favorite';
      return;
    }

    // play in place
    playlistMeta = songs;
    trackList = songs.map(s => ({ url: s.url, title: s.title, length: '' }));
    playIndex(i);
  };
});


Router.on('favorites/concerts', async ()=>{
  show($('#toolbar-bands'),false); show($('#toolbar-band'),false); show($('#showMeta'),false);
  const content=$('#content'); content.className='grid';

  const ids = favShows();

  const actions = document.createElement('div');
  actions.className='pageActions';
  actions.innerHTML = `
    <button class="btn" id="favShowsPlayAll">▶️ Play All</button>
    <button class="btn" id="favShowsShuffleAll">🔀 Shuffle All</button>
  `;
  content.innerHTML = '';
  content.appendChild(actions);

  if(!ids.length){
    const empty = document.createElement('div'); empty.className='card';
    empty.innerHTML = `<span class="small">No favorite concerts yet.</span>`;
    content.appendChild(empty);
    return;
  }

  try{
    const batchSize = 40;
    let docs = [];
    for(let i=0;i<ids.length;i+=batchSize){
      const batch = ids.slice(i, i+batchSize);
      const data = await fetchIA(IA.concertsByIdsUrl(batch));
      docs = docs.concat((data?.response?.docs)||[]);
    }

    if(!docs.length){
      ids.forEach(id=>{
        const card = document.createElement('div'); card.className='card fav';
        card.innerHTML = `
          <div>
            <h3 class="title">${id}</h3>
            <div class="small">Favorite Concert</div>
          </div>
          <div class="row">
            <button class="btn" data-open="${id}">Open</button>
            <button class="btn ghost is-on" data-unfav="${id}" title="Remove">★</button>
          </div>`;
        content.appendChild(card);
      });
    }else{
      content.insertAdjacentHTML('beforeend', docs.map(it=>{
        const dateStr = it.date ? new Date(it.date).toLocaleDateString() : (it.year||'');
        const reviews = it.num_reviews||0;
        const venueLine = [it.venue, it.coverage].filter(Boolean).join(', ');
        const viewsChip = `<span class="chip">${fmtCompact(it.downloads||0)} views</span>`;
        return `
          <div class="card tap fav" data-id="${it.identifier}">
            <div>
              <h3 class="title">${it.title || it.identifier}</h3>
              <div class="row">
                <span class="chip">${dateStr}</span>
                ${viewsChip}
                ${renderStars(it.avg_rating||0)} <span class="small">(${reviews})</span>
              </div>
              <div class="small">${venueLine}</div>
            </div>
            <div class="row">
              <button class="btn ghost favToggle is-on" title="Favorite">★</button>
            </div>
          </div>`;
      }).join(''));
    }

    // Wire the action buttons
    $('#favShowsPlayAll').onclick = ()=> startShowQueue(false);
    $('#favShowsShuffleAll').onclick = ()=> startShowQueue(true);

    function startShowQueue(shuffle){
      showQueue = ids.slice();
      if(shuffle) shuffleArray(showQueue);
      showQueuePos = 0; queueShowsActive = true; persistShowQueue();

      // Mark origin before navigating into the first show
      store.set('cameFrom', 'favorites-concerts');

      store.set('autoPlayOnLoad', true);
      location.hash = '#/show/' + encodeURIComponent(showQueue[0]);
    }

    // Card interactions (open / unfavorite)
    content.onclick = (e)=>{
      const card = e.target.closest('.card.tap');

      if (e.target.closest('.favToggle')){
        const id = card ? card.dataset.id : e.target.getAttribute('data-unfav');
        if(id){ toggleFavShow(id); Router.route(); }
        return;
      }

      if (card){
        // Mark origin before navigating into a specific show
        store.set('cameFrom', 'favorites-concerts');
        location.hash = '#/show/' + encodeURIComponent(card.dataset.id);
        return;
      }

      const open = e.target.getAttribute('data-open');
      if(open){
        // Mark origin for "Open" button as well
        store.set('cameFrom', 'favorites-concerts');
        location.hash = '#/show/'+encodeURIComponent(open);
        return;
      }

      const unf  = e.target.getAttribute('data-unfav');
      if(unf){ toggleFavShow(unf); Router.route(); return; }
    };
  }catch(e){
    const err = document.createElement('div'); err.className='card';
    err.innerHTML = `<span class="small">Failed to load favorite concerts.</span>`;
    content.appendChild(err);
  }
});




Router.on('favorites/songs', ()=>{
  show($('#toolbar-bands'),false); show($('#toolbar-band'),false); show($('#showMeta'),false);
  const content=$('#content'); content.className='tracks';
  const songs = favSongs();
  const actions = document.createElement('div');
  actions.className='pageActions';
  actions.innerHTML = `
    <button class="btn" id="favSongsPlayAll">▶️ Play All</button>
    <button class="btn" id="favSongsShuffleAll">🔀 Shuffle All</button>
  `;
  content.innerHTML = '';
  content.appendChild(actions);

  if(!songs.length){
    const empty = document.createElement('div'); empty.className='card'; empty.innerHTML = `<span class="small">No favorite songs yet.</span>`;
    content.appendChild(empty); return;
  }

  // Render songs list
  const listWrap = document.createElement('div'); listWrap.className='tracks';
  listWrap.style.padding='0 12px 120px';
listWrap.innerHTML = songs.map((t,i)=>`
  <div class="track favsong" data-i="${i}">
    <div class="line1">
      <div class="tleft">
        <button class="songFav is-on" title="Unfavorite">★</button>
        <div class="tnum">${i+1}</div>
        <div class="tname">${t.title}</div>
      </div>
      ${t.band ? `<span class="pill pill-sm bandpill">${t.band}</span>` : ''}
    </div>

<div class="line2">
  ${t.location ? (
    t.showId
      ? `<a class="pill pill-sm locpill" href="#/show/${encodeURIComponent(t.showId)}">${t.location}</a>`
      : `<span class="pill pill-sm locpill">${t.location}</span>`
  ) : ''}

  ${t.date ? `<span class="pill pill-sm datepill">${t.date}</span>` : ''}
</div>


    <div class="progressBar" id="pb-${i}"></div>
  </div>
`).join('');


  content.appendChild(listWrap);
  trackEls = Array.from(listWrap.querySelectorAll('.track'));
  // Play All / Shuffle All
  $('#favSongsPlayAll').onclick = ()=> startFavSongs(false);
  $('#favSongsShuffleAll').onclick = ()=> startFavSongs(true);

function startFavSongs(shuffle){
  const arr = songs.slice();
  if (shuffle) shuffleArray(arr);

  // Play inline on the Favorites → Songs page
  currentShowId   = 'favorites_songs';
  currentShowBand = arr[0]?.band || '';        // helps Now-Playing metadata
  playlistMeta    = arr;                       // keep song meta (band/date/etc.)
  trackList       = arr.map(t => ({ url: t.url, title: t.title, length: '' }));

  playIndex(0);
}


  // Interactions
listWrap.onclick = (e)=>{
  // If user clicked the location link, remember the track and let the link navigate
  const locLink = e.target.closest('a.locpill');
  if (locLink) {
    const row = e.target.closest('.track');
    if (row) {
      const i = Number(row.dataset.i);
      const t = songs[i];
      if (t?.url) store.set('jumpToUrl', t.url);
      // Mark origin so the Show header can say "← Favorite Songs"
      store.set('cameFrom', 'favorites-songs');
    }
    return; // allow default hash navigation
  }

  const tr = e.target.closest('.track'); if (!tr) return;
  const i = Number(tr.dataset.i);
  const t = songs[i];

  // Play inline starting at the tapped song
  currentShowId   = 'favorites_songs';
  currentShowBand = t?.band || '';
  playlistMeta    = songs;  // keep meta for Now-Playing and pills
  trackList       = songs.map(s => ({ url: s.url, title: s.title, length: '' }));

  playIndex(i);
};


});



/* ------------ Playlist route (fav-songs, recent-songs) ------------ */

/* Standalone, global function */
function renderFavSongsPlaylist(){
  show($('#toolbar-bands'),false); show($('#toolbar-band'),false); show($('#showMeta'),false);
  const content = $('#content'); content.className = 'tracks';

  const pl = store.get('playlist_fav_songs', []);
  if (!pl.length){
    content.innerHTML = `<div class="card"><span class="small">No songs to play.</span></div>`;
    return;
  }

  // Use standard track list + player
  currentShowId = 'favorites_songs';
  trackList = pl.map(t => ({ url: t.url, title: t.title, length: '' }));

  content.innerHTML = trackList.map((t,i)=>`
    <div class="track" data-i="${i}">
      <div class="tleft">
<button class="songFav${ findSongIdx(t.url)>=0 ? ' is-on' : '' }" title="Favorite song">
  ${ findSongIdx(t.url)>=0 ? '★' : '☆' }
</button>       
        <div class="tnum">${i+1}</div>
        <div class="tname">${t.title}</div>
      </div>
      <div class="tlen"></div>
      <div class="progressBar" id="pb-${i}"></div>
    </div>`).join('');
  trackEls = $$('.track');
  
  // If we arrived via the Now-Playing button, jump to the exact track
const jumpUrl = store.get('jumpToUrl', null);
if (jumpUrl) {
  store.set('jumpToUrl', null); // one-time use
  const idx = trackList.findIndex(t => t.url === jumpUrl);
  if (idx >= 0) {
    // Sync highlight with what's playing
    curIndex = idx;
    updateTrackHighlight();

    // Scroll into view and pulse
    const el = document.querySelector(`.track[data-i="${idx}"]`);
    if (el) {
      el.scrollIntoView({ block: 'center', behavior: 'smooth' });
      el.classList.add('pulse');
      setTimeout(()=> el.classList.remove('pulse'), 1800);
    }
  }
}


  
  content.onclick = ev => {
    const favBtn = ev.target.closest('.songFav');
    if (favBtn){
      const tr = ev.target.closest('.track'); if(!tr) return;
      const idx = Number(tr.dataset.i);
      toggleFavSong({ url: trackList[idx].url, title: trackList[idx].title, showId: 'favorites_songs' });
      favBtn.textContent = findSongIdx(trackList[idx].url) >= 0 ? '★' : '☆';
      return;
    }
    const tr = ev.target.closest('.track'); if (!tr) return;
    playIndex(Number(tr.dataset.i));
  };

  // Autoplay first item when entering playlist
  playIndex(0);
}

/* Standalone, global function */
function renderRecentSongsPlaylist(){
  show($('#toolbar-bands'),false); show($('#toolbar-band'),false); show($('#showMeta'),false);
  const content = $('#content'); content.className = 'tracks';

  const pl = store.get('playlist_recent_songs', []);
  if (!pl.length){
    content.innerHTML = `<div class="card"><span class="small">No songs to play.</span></div>`;
    return;
  }

  // Use standard track list + player
  currentShowId = 'recent_songs';
  trackList = pl.map(t => ({ url: t.url, title: t.title, length: '' }));

  content.innerHTML = trackList.map((t,i)=>`
    <div class="track" data-i="${i}">
      <div class="tleft">
<button class="songFav${ findSongIdx(t.url)>=0 ? ' is-on' : '' }" title="Favorite song">
  ${ findSongIdx(t.url)>=0 ? '★' : '☆' }
</button>

        <div class="tnum">${i+1}</div>
        <div class="tname">${t.title}</div>
      </div>
      <div class="tlen"></div>
      <div class="progressBar" id="pb-${i}"></div>
    </div>`).join('');
  trackEls = $$('.track');

  content.onclick = ev => {
    const favBtn = ev.target.closest('.songFav');
    if (favBtn){
      const tr = ev.target.closest('.track'); if (!tr) return;
      const idx = Number(tr.dataset.i);
      toggleFavSong({ url: trackList[idx].url, title: trackList[idx].title, showId: 'recent_songs' });
      favBtn.textContent = findSongIdx(trackList[idx].url) >= 0 ? '★' : '☆';
      favBtn.classList.toggle('is-on', findSongIdx(trackList[idx].url) >= 0);

      return;
    }
    const tr = ev.target.closest('.track'); if (!tr) return;
    playIndex(Number(tr.dataset.i));
  };

  // Autoplay first recent song
  playIndex(0);
}

/* Router hook */
Router.on('playlist', (params)=>{
  const listId = (params||[])[0]||'';
  if (listId==='fav-songs')         renderFavSongsPlaylist();
  else if (listId==='recent-songs') renderRecentSongsPlaylist();
  else {
    const c=$('#content'); c.className='grid';
    c.innerHTML=`<div class="card"><span class="small">Empty playlist.</span></div>`;
  }
});


/* ------------ wire base routes ------------ */
Router.on('bands', showBands);
Router.on('band', showBand);
Router.on('show', showShow);
Router.on('onthisday', showOnThisDay);  // NEW


/* ------------ bands filters ------------ */
$('#sortSel')?.addEventListener('change', showBands);
$('#searchBox')?.addEventListener('change', showBands);
$('#favToggle')?.addEventListener('click', ()=>{
  onlyFavBands = !onlyFavBands;
  $('#favToggle').textContent = onlyFavBands ? '★ Favorites' : '☆ Favorites';
  $('#favToggle').classList.toggle('is-on', !!onlyFavBands); // visual ON
  showBands();
});
$('#resetBtn')?.addEventListener('click', ()=>{
  $('#sortSel').value='downloads desc';
  $('#searchBox').value='';
  onlyFavBands = false;
  $('#favToggle').textContent = '☆ Favorites';
  $('#favToggle').classList.remove('is-on');
  location.hash='#/bands';
  showBands();
});


/* ------------ optional SW ------------ */
if('serviceWorker' in navigator){ navigator.serviceWorker.register('sw.js').catch(()=>{}); }

/* Init eq state once DOM is ready */
document.addEventListener('DOMContentLoaded', updateEqAnim);

/* ------------ utils ------------ */
function shuffleArray(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}
</script>
  <script>
/* Measure player height and set padding so content never hides underneath */
(function () {
  function setPlayerHeightPadding(){
    const bar = document.getElementById('P_bar')
              || document.querySelector('#playerBar, .playerBar, #P_now');
    if (!bar) return;
    const h = bar.offsetHeight || 96;
    document.documentElement.style.setProperty('--playerH', h + 'px');
  }
  window.addEventListener('resize', setPlayerHeightPadding);
  document.addEventListener('DOMContentLoaded', setPlayerHeightPadding);
  // In case the player renders after JS init (route change, etc.)
  setTimeout(setPlayerHeightPadding, 0);
})();
</script>

</body>
</html>
